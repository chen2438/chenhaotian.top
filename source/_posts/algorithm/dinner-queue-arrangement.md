---
description: 发布于 2025-01-09
categories:
- algorithm
date: 2025-01-09
slug: dinner-queue-arrangement
title: ZSTUOJ 晚餐队列安排
updated: 
tags: 
- algorithm
copyright: false
---

# ZSTUOJ 晚餐队列安排

## 题目描述

为了避免餐厅过分拥挤，FJ要求奶牛们分2批就餐。每天晚饭前，奶牛们都会在餐厅前排队入内，按FJ的设想，所有第2批就餐的奶牛排在队尾，队伍的前半部分则由设定为第1批就餐的奶牛占据。由于奶牛们不理解FJ的安排，晚饭前的排队成了一个大麻烦。

第i头奶牛有一张标明她用餐批次D_i(1 <= D_i <= 2)的卡片。虽然所有N(1 <= N <= 30,000)头奶牛排成了很整齐的队伍，但谁都看得出来，卡片上的号码是完全杂乱无章的。

在若干次混乱的重新排队后，FJ找到了一种简单些的方法：奶牛们不动，他沿着队伍从头到尾走一遍，把那些他认为排错队的奶牛卡片上的编号改 掉，最终得到一个他想要的每个组中的奶牛都站在一起的队列，例如112222或111122。有的时候，FJ会把整个队列弄得只有1组奶牛（比方 说，1111或222）。

你也晓得，FJ是个很懒的人。他想知道，如果他想达到目的，那么他最少得改多少头奶牛卡片上的编号。所有奶牛在FJ改卡片编号的时候，都不会挪位置。

**输入**

- 第1行: 1个整数：N

- 第2..N+1行: 第i+1行是1个整数，为第i头奶牛的用餐批次D_i

**输出**

- 第1行: 输出1个整数，为FJ最少要改几头奶牛卡片上的编号，才能让编号变成他设想中的样子

**样例输入**

```
7
2
1
1
1
2
2
1
```

**样例输出**

```
2
```

## 思路

用一个前缀数组`pre2[i]`表示前`i`个数中`2`的个数，后缀数组`suf1[i]`表示后`i`个数中`1`的个数

遍历整个序列，假定第`i`个位置及其前面都变成`1`，第`i+1`个位置及其后面都变成`2`，那么代价 = `pre2[i] + suf1[i+1]`，取代价的最小值

## 代码

```cpp
#include <iostream>
using namespace std;

int a[30010];
int pre2[30010], suf1[30010]; // pre2[i]表示前i个数中2的个数，suf1[i]表示后i个数中1的个数

int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    pre2[0] = 0;
    for (int i = 1; i <= n; i++) {
        if (a[i] == 2)
            pre2[i] = pre2[i - 1] + 1;
        else
            pre2[i] = pre2[i - 1];
    }
    suf1[n + 1] = 0;
    for (int i = n; i >= 1; i--) {
        if (a[i] == 1)
            suf1[i] = suf1[i + 1] + 1;
        else
            suf1[i] = suf1[i + 1];
    }
    int ans = 30010;
    for (int i = 0; i <= n; i++) { // 注意i要从0开始
        ans = min(ans, pre2[i] + suf1[i + 1]);
    }
    cout << ans << endl;
    return 0;
}
```

